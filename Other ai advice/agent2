I read your entire context carefully and re‑audited the code you shared. The 401 from /auth/exchange-token is not caused by a “wrong key format.” In your current code base the temp‑token key names do match. The failure happens because you’re currently in non‑Redis (filesystem) session mode, and the cross‑site fetch from the frontend to the backend does not send the backend session cookie, so the backend can’t see the temp token stored in that server session—and returns 401.

Below is a tight, copy‑paste set of fixes that will make the flow work today, plus optional Redis hardening.

Root cause (why 401 happens now)

In the OAuth callback you create a temp token and (without Redis) stash it in the Flask server session under session[f'auth_token_{auth_token}'] = {...}. This code is correct. 

oauth_handler

In /auth/exchange-token (non‑Redis path) you session.pop(f'auth_token_{temp_token}', None)—also correct. 

oauth_handler

But the POST to /auth/exchange-token comes from https://taskpages-frontend.onrender.com
 → https://taskpages-backend.onrender.com
. With fetch, cookies are not sent unless you set credentials: 'include', and the session cookie must be SameSite=None; Secure. Right now that cookie is Lax, so the backend can’t see the session and the pop returns None → 401.
(Your Security middleware and CORS are already set up to allow credentials for whitelisted origins, so once the cookie is actually sent, it’ll be accepted.) 

security_middleware

Reality check vs. “key mismatch”: In your codebase, the store/pop key format matches (both use auth_token_{token}). The issue is the request has no session, not a mismatched key. 

oauth_handler

Fix it now (5 minimal changes)
1) Send cookies on the token exchange (frontend)

Add credentials: 'include' to the only cross‑site call that must touch the server session: /auth/exchange-token.

/index.html – change exchangeToken: 

index

async function exchangeToken(tempToken) {
    try {
        const response = await fetch(`${BACKEND_URL}/auth/exchange-token`, {
            method: 'POST',
+           credentials: 'include',     // <-- send backend session cookie
            headers: {
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            },
            body: JSON.stringify({ token: tempToken })
        });


You already use credentials: 'include' in your /auth/status check; this just applies it to the exchange POST as well. 

index

2) Allow the backend session cookie to be sent cross‑site

Right after SecureConfig.init_app(app) in your Flask app, ensure the cookie attributes are correct for cross‑site fetch:

app_secure.py – after app creation/init: 

app_secure

# After: app = Flask(__name__); SecureConfig.init_app(app)
app.config.update(
    SESSION_COOKIE_SAMESITE='None',  # cross-site POSTs must be None
    SESSION_COOKIE_SECURE=True,      # required by browsers when SameSite=None
    SESSION_COOKIE_HTTPONLY=True
)


You’re using Flask‑Session with filesystem fallback already; these attributes govern the cookie the browser will send to /auth/exchange-token. 

app_secure

3) Make sure CORS allows credentials from the frontend origin

You already set CORS and your security middleware mirrors the Access-Control-Allow-Origin for allowed origins. Just confirm the frontend origin appears in CORS_ORIGINS so the response includes both Access-Control-Allow-Origin: https://taskpages-frontend.onrender.com and Access-Control-Allow-Credentials: true. 

app_secure

 

security_middleware

No code snippet needed if your env/config already lists it; just verify the header is present in the /auth/exchange-token response.

4) Return users to the page they started on (instead of always frontend root)

Right now, login_required stores next_url as an absolute backend URL (e.g., /pages/wait-node-v2?...), but the callback only accepts next_url if it’s relative or starts with FRONTEND_URL—so you always land on the frontend root and lose the context. Allow BACKEND_URL too.

oauth_handler.py – inside /auth/callback before computing redirect_url: 

oauth_handler

next_url = session.pop('next_url', None)
- if next_url and next_url.startswith(('/', current_app.config['FRONTEND_URL'])):
+ allowed_prefixes = [current_app.config['FRONTEND_URL'], current_app.config['BACKEND_URL']]
+ if next_url and (next_url.startswith('/') or any(next_url.startswith(p) for p in allowed_prefixes)):
    redirect_url = f"{next_url}?auth=success&token={auth_token}"
else:
    redirect_url = f"{current_app.config['FRONTEND_URL']}?auth=success&token={auth_token}"


This preserves deep links to /pages/wait-node-v2?task_id=... after login. 

app_secure

5) Make the secure pages resilient when localStorage is empty on the backend origin

Your secure pages (served from the backend) currently force an auth_token from localStorage and redirect to /index.html if absent—but localStorage is per origin, so the token you stored on the frontend origin isn’t visible on the backend. Two small changes fix this:

A. Save a “send me back here” pointer before leaving the page.
In both wait‑node pages, right before window.location.href = '/index.html', set:

+ sessionStorage.setItem('redirect_after_login', window.location.href);
  window.location.href = '/index.html';


Files: wait-node.html and wait-node-v2.html. 

wait-node

 

wait-node-v2

B. Accept the backend session cookie as an alternative to a bearer token.
Instead of failing when localStorage.auth_token is missing, first call /auth/status same‑origin without an Authorization header; if it returns authenticated: true, just proceed.

Example drop‑in (v2 structure, same idea for v1): 

wait-node-v2

- checkAuthentication() {
-   const token = this.getAuthToken();
-   if (!token) {
-     console.log('No auth token found, redirecting to login...');
-     window.location.href = '/index.html';
-     return false;
-   }
-   return true;
- }
+ async function checkAuthentication() {
+   const token = localStorage.getItem('auth_token');
+   if (token) return true;             // Bearer path still works
+   // Fallback: cookie-based session (since this page is on the backend origin)
+   try {
+     const res = await fetch(`${window.location.origin}/auth/status`, {
+       credentials: 'include', headers: { 'Accept': 'application/json' }
+     });
+     const data = await res.json();
+     if (data.authenticated) return true;
+   } catch {}
+   sessionStorage.setItem('redirect_after_login', window.location.href);
+   window.location.href = '/index.html';
+   return false;
+ }


Your backend API routes already accept cookie‑based sessions via @login_required, so this one change unlocks same‑origin API calls without needing a bearer token when you’re on the backend domain. 

app_secure

Optional but recommended: Redis = zero cookie coupling for the exchange

When Redis is up, /auth/exchange-token does not need a browser cookie—the temp token and session are looked up entirely in Redis (see the auth_token: and api_token: keys), which is rock‑solid for cross‑domain flows. 

oauth_handler

Render checklist to re‑enable Redis:

Set DISABLE_REDIS=false.

Set a proper REDIS_URL using TLS (e.g., rediss://:PASSWORD@HOST:PORT/0).

Remove any SESSION_TYPE override that forces filesystem. Your app already falls back to filesystem if Redis can’t connect. 

app_secure

Quick answers to your “Questions for Debugging”

“Why is the token in the redirect URL different from the session storage key?”
It isn’t, logically—the code stores under auth_token_{token} and later pops auth_token_{token}. The 401 is because the exchange request doesn’t carry the backend session cookie (non‑Redis mode), so the backend can’t see that key at all. 

oauth_handler

“Should we use JWT instead of session tokens?”
Not required. Your current design (short‑lived temp token → long‑lived API token, both server‑validated) is safer than unsigned client JWTs and avoids clock‑skew/signing pitfalls. If you want JWTs, keep them opaque to the client and still validate server‑side (or sign/rotate keys properly). The simplest hardening is: get Redis working so exchange is cookie‑free. 

oauth_handler

“Is filesystem session storage reliable on Render?”
It works but is not ideal: ßpods are ephemeral and horizontally scaled instances don’t share state. You already guard with Flask‑Session; for scale & reliability use Redis (single source of truth, TTLs, logout everywhere). 

app_secure

“Should everything run on one domain?”
Not necessary. With either (a) Redis enabled, or (b) credentials: 'include' + SameSite=None; Secure cookie, cross‑domain works cleanly for your current split frontend/static + backend/API design. If you ever unify, flows simplify but you lose the static hosting benefits.

One more hygiene item

Callback redirect filtering (above) will finally return users to /pages/wait-node(-v2) with task_id intact.

Consider retiring auth_success.html—it doesn’t match your current exchange flow and can confuse future debugging. 

auth_success

The wait‑node v1 page references undefined EDGE_FUNCTION_URL/PROFILE; either remove that path or migrate to the backend approve route as v2 does. 

wait-node

 

app_secure

Sanity test (end‑to‑end)

Hit https://taskpages-backend.onrender.com/pages/wait-node-v2?task_id=868fkbrfv.

You’ll be bounced to Google, back to /auth/callback, the backend sets the session cookie, and you’re redirected to the frontend with ?auth=success&token=.... 

oauth_handler

On the frontend, exchangeToken() runs with credentials: 'include', the backend sees the session, mints the api_token, and you store it in localStorage. 

index

 

oauth_handler

Index will auto‑redirect you back to redirect_after_login.

The secure page uses same‑origin API calls. With our fallback, it works even if localStorage on the backend origin is empty (cookie session is sufficient). 

wait-node-v2

 

app_secure

If you want, paste a failing /auth/exchange-token response’s headers (especially Set-Cookie from /auth/callback and the Access-Control-* headers) and the X‑Request‑ID—we can verify the CORS + cookie attributes in one shot.
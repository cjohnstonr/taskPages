Got it—I read through all of your code and the full incident report. I’m going to give you (1) a precise root‑cause analysis of the 401, (2) the minimal code changes to get the current flow working on Render, (3) a hardened plan so the app works reliably across the two Render subdomains, and (4) answers to your specific questions. I’ll cite exact places in your code and a couple of Render/Flask references as I go.

TL;DR: Why you get 401 Unauthorized on /auth/exchange-token

Two things are colliding:

Your frontend doesn’t send the backend session cookie on the exchange call.
exchangeToken() posts cross‑site to https://taskpages-backend.onrender.com/auth/exchange-token without credentials: 'include'. So the browser omits the taskpages_session cookie; the backend sees a new session and can’t find the stored auth_token_* entry. Result: 401. See the code—no credentials option here. 

index

Even if you add credentials: 'include', your cookie is SameSite=Lax, which the browser will still not send on a cross‑site fetch POST.
Your config sets SESSION_COOKIE_SAMESITE = 'Lax'. For cross‑site XHR/fetch, modern browsers only send the cookie when SameSite=None; Secure. With Lax, the cookie is only sent on top‑level navigations, not background requests. 

security


(Background: browsers require SameSite=None; Secure for third‑party/cross‑site cookies. 
Stack Overflow
)

Because of #1 + #2, the non‑Redis fallback path in /auth/exchange-token that looks up session.pop(f'auth_token_{temp_token}') can never see the token from the earlier OAuth callback session, so it returns 401. 

oauth_handler

Important: The “token mismatch” you saw (URL token 5Xuf... vs. session key auth_token_ySGD...) is a red herring. Your code intentionally stores the token as part of the session key name (auth_token_{token}), not as the value. With the correct session cookie, those do line up. 

oauth_handler

Minimal hot‑fix (works today)

Make these two small changes to get the current design working immediately on Render:

1) Send credentials on the exchange call (frontend)
// index.html
 async function exchangeToken(tempToken) {
     try {
         const response = await fetch(`${BACKEND_URL}/auth/exchange-token`, {
             method: 'POST',
+            credentials: 'include',
             headers: {
                 'Content-Type': 'application/json',
                 'Accept': 'application/json'
             },
             body: JSON.stringify({ token: tempToken })
         });


This is the missing piece in your current index.html. (Notice you do pass credentials: 'include' on /auth/status, but not on the exchange.) 

index

 

index

2) Allow cross‑site cookies for the exchange POST (backend)

Switch cookies to SameSite=None in production:

# security.py
- SESSION_COOKIE_SAMESITE = 'Lax'
+ SESSION_COOKIE_SAMESITE = 'None'   # required for cross-site fetch POSTs


You already set SESSION_COOKIE_SECURE in prod, which browsers require when SameSite=None. So this change is safe and standards‑conformant. 

security

 Background: browsers only send cookies on cross‑site fetch if SameSite=None; Secure. 
Stack Overflow

After these two edits, the same backend session that created auth_token_{temp} during OAuth callback will be visible to /auth/exchange-token, the lookup will succeed, and you’ll get your long‑lived API token back.

One more must‑fix to unblock API calls from the static frontend

Right now, your protected API routes use @login_required, which only checks the Flask session cookie (server‑side session) and ignores the Authorization: Bearer … header that your frontend sends. That means even after you obtain an API token, any cross‑domain API call will 401 unless the cookie is also present. Here is your decorator that only uses get_user_session() (cookie). 

oauth_handler

Add bearer‑token support to the decorator:

# oauth_handler.py
 def login_required(f):
     """
     Decorator to require authentication for routes
     """
     @wraps(f)
     def decorated_function(*args, **kwargs):
-        user_session = get_user_session()
+        # 1) Try Bearer token for API requests (cross-domain)
+        auth_header = request.headers.get('Authorization', '')
+        if auth_header.startswith('Bearer '):
+            token = auth_header[7:]
+            user_session = validate_api_token(token) or validate_auth_token(token)
+            if user_session:
+                request.user = user_session
+                return f(*args, **kwargs)
+
+        # 2) Fallback to cookie session (same-origin pages)
+        user_session = get_user_session()
         if not user_session:
             if request.is_json:
                 return jsonify({'error': 'Authentication required'}), 401
             session['next_url'] = request.url
             return redirect(url_for('auth.login'))
         request.user = user_session
         return f(*args, **kwargs)


You already have validate_api_token and validate_auth_token implemented; we’re just using them in the decorator. 

oauth_handler

Redis on Render: fix the connection & stop relying on filesystem sessions

Your logs show Error 22 connecting to oregon-redis.render.com:6380. On Render, the external Key‑Value (Redis‑compatible) URL uses rediss:// over TLS, typically on port 6379, not 6380. Use the exact URL Render gives you (you’ll see rediss://...@<REGION>-kv.render.com:6379). 
Render

Action:

Set REDIS_URL to the exact Render Key Value URL, e.g.

REDIS_URL=rediss://red-xxxxxxxxxxxxxxxxxxxx:PASSWORD@oregon-kv.render.com:6379


Do not hardcode 6380. Your init_redis already uses redis.from_url(REDIS_URL) and will switch to TLS when the scheme is rediss://. 

oauth_handler

Why this matters: with Redis available, your exchange endpoint avoids cookies entirely by reading auth_token:{temp} and then writing api_token:{long} in Redis with a TTL. That design is robust for cross‑domain SPAs and works even if the browser can’t/won’t send session cookies. 

oauth_handler

“Ship‑it” patch set (all diffs together)

index.html – send cookies on exchange
Add credentials: 'include' inside exchangeToken() (see above). 

index

security.py – allow cross‑site POST during exchange
Change SESSION_COOKIE_SAMESITE = 'None' (keep SESSION_COOKIE_SECURE=True for prod). 

security

oauth_handler.py – accept Bearer tokens in @login_required
Update decorator to check Authorization: Bearer … before falling back to cookie session. (Your /auth/status already does this; we’re aligning the rest.) 

oauth_handler

 

oauth_handler

Render env – correct Redis URL
Put Render’s provided rediss://…:6379 into REDIS_URL. 
Render

Sanity checks you can run right now

After implementing the above:

OAuth → redirect arrives with ?auth=success&token=....

Network tab: POST /auth/exchange-token shows:

Request has Origin https://taskpages-frontend.onrender.com.

withCredentials: true (because credentials:'include').

Response 200 with { success: true, api_token: "..." }.

localStorage.auth_token is set (frontend). Subsequent GET /auth/status should return authenticated either via:

Authorization: Bearer <api_token> → validated by Redis (validate_api_token) (best), or

cookie session (for backend‑served pages).

API calls from the frontend domain to /api/... now succeed because @login_required honors the Bearer token.

Longer‑term hardening (recommended)

If you want to be resilient even when Redis is down:

Stateless temporary tokens. When Redis is unavailable, mint a short‑lived JWT (signed with SECRET_KEY) as the temp token and embed the essentials (email, iat, exp). /auth/exchange-token can verify the JWT signature and immediately issue an API JWT (or write to Redis if it’s back). That removes the last cookie dependency in the exchange path.

Single auth paradigm. Prefer token‑based auth for all /api endpoints (Bearer JWT or Redis token). Keep cookie sessions only for server‑rendered pages.

Scope & TTL. Keep the temp token TTL <= 5 minutes (you already do this with Redis) and API token TTL ~8–24 hours. Support /auth/logout + blacklist only when Redis is present.

Answers to your questions

Why is the token in the redirect URL different from the session storage key?
It’s not semantically different—the session uses the token value as part of the key name (auth_token_{token}), but your exchange handler needs the same session cookie to see that key. The 401 came from the cookie not being sent (and later blocked by SameSite=Lax). 

oauth_handler

 

oauth_handler

Should we use JWT tokens instead of session‑based tokens?
Yes—for cross‑domain SPAs, JWT (or at least a Redis‑backed bearer token) is the cleanest. You already have Redis tokens for api_token:{...}—that’s good. For no‑Redis fallback, consider JWTs so /api does not depend on cookies.

Is filesystem session storage reliable on Render’s ephemeral containers?
It’s OK only for a single container lifetime. On redeploy/restart, sessions are gone. Use Render Key Value (Redis‑compatible) for sessions/tokens.

Should everything run on one domain to avoid cross‑domain issues?
It simplifies things (cookies with SameSite=Lax work out‑of‑the‑box). But with the fixes above (Bearer tokens + SameSite=None just for the one exchange call, or JWT‑only), you can safely keep the split deployment.

Other observations you may want to clean up

/auth/status already understands Bearer tokens—good. Make the decorator consistent (patch above). 

oauth_handler

Security middleware already sets Access-Control-Allow-Credentials: true for allowed origins—good. 

security_middleware

auth_success.html writes localStorage on the backend origin. That storage isn’t visible to the frontend origin; this page isn’t used in your current redirect anyway—safe to delete to reduce confusion. 

auth_success

CSP in security.py limits connect-src to 'self' and BACKEND_URL for pages served by the backend. This doesn’t affect your static frontend, but keep it in mind if you later serve the SPA from the backend. 

security

Render + TLS notes for Redis (so you don’t fight ports again)

Render’s Key‑Value docs show external connections use rediss:// and TLS on 6379 (the URL they give you). Don’t force 6380. Example from the docs:
rediss://red-xxxxxxxxxxxxxxxxxxxx:PASSWORD@HOST:6379 (with tls: true if your client needs an explicit flag). 
Render

Quick checklist you can follow

Frontend: add credentials: 'include' in exchangeToken(). 

index

Backend: set SESSION_COOKIE_SAMESITE='None' (keep Secure=True). 

security

Backend: update @login_required to accept Authorization: Bearer …. 

oauth_handler

 

oauth_handler

Render env: set REDIS_URL to the exact rediss URL on 6379 from Render. 
Render

Test: OAuth → auth=success&token=… → exchange → api_token → GET /auth/status (Bearer) returns authenticated → protected /api/... calls succeed.

A couple of clarifiers (optional, to perfect the setup)

Which exact REDIS_URL are you using in Render (can you paste the hostname/port, masking the password)? I want to sanity‑check it against the Oregon Key Value endpoint format.

Do you want me to convert the non‑Redis fallback to stateless JWT temp/API tokens so even the exchange path never needs a cookie?

If you’d like, I can prepare drop‑in diffs for all three files (index.html, security.py, oauth_handler.py) exactly as above.